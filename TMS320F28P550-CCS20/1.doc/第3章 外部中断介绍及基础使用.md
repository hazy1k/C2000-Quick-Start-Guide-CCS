# 第三章 外部中断介绍及基础使用

## 1. F28P550的中断系统

C28x CPU 有 14个 外围中断线。其中两个中断（INT13和INT14）分别直接连接到CPU定时器1和2。其余的12个中断通过增强型外设中断扩展模块（ePIE，或简称PIE）连接到外设中断信号。PIE将多达16个外设中断复用到每个CPU中断线，并扩展向量表以允许每个中断具有ISR（中断服务程序）。这使得CPU能够支持大量外设。

中断路径分为3个阶段：外设（peripheral）、PIE 和 CPU。每个阶段都有启用寄存器和标志位寄存器。系统允许CPU处理一个中断，让其他中断等待，在软件中就可以实现优先级嵌套中断，并在某些关键任务期间禁用中断。下图给出了F28P550的中断架构

![](https://wiki.lckfb.com/storage/images/zh-hans/tjx-tms320f28p550/beginner/interrupt/interrupt_20250521_195934.png)

在上图中，可以发现，TMS320F28P550 GPIO中断，只有5个通道 XINT1 ~ XINT5​​，在引脚中断上支持边沿触发（上升沿、下降沿或双边沿），用于快速响应外部事件（如按键、传感器信号等）。中断触发后，CPU 会暂停当前任务，跳转到中断服务程序（ISR）执行，完成后恢复原程序。

## 2. 外部中断使用示例

使用KEY按键触发蓝色LED灯点亮和熄灭，软件上将KEY按键的引脚配置使用CPU外部中断的方式。

### 2.1 CCS&syscfg配置

打开工程下的 .syscfg 文件。配置KEY按键的引脚为GPIO输入模式，并开启外部中断，配置为下降沿触发中断。

![](https://wiki.lckfb.com/storage/images/zh-hans/tjx-tms320f28p550/beginner/interrupt/interrupt_20250516_111203.png)

因为案例中用到了蓝色LED灯用来展示状态，所以还需要配置LED灯的引脚为输出模式。

![](https://wiki.lckfb.com/storage/images/zh-hans/tjx-tms320f28p550/beginner/interrupt/interrupt_20250521_202618.png)

### 2.2 用户代码

配置开启了中断服务函数的配置后，后面在写代码时，需要根据配置的中断服务函数名称编写对应的中断程序。根据上图的配置，到时候在代码中加入外部中断函数即可：

```c
//KEY引脚的外部中断服务函数
__interrupt void INT_GPIO_KEY_XINT_ISR(void)
{
  //要在中断实现的功能

  //清除中断标志位
  Interrupt_clearACKGroup(INTERRUPT_ACK_GROUP1);
}
```

## 3. C2000 外部中断 (XINT) 相关函数总结 (基于DriverLib)

> **注**：本总结以TMS320F2837x/Dx系列为例。C2000的外部中断通常由**XINT**（External Interrupt）模块管理，并通过**PIE**（外设中断扩展）模块连接到CPU内核。其他型号概念相通，但XINT数量和支持的触发方式可能不同。

### 3.1 外部中断概述与核心概念

C2000的外部中断并非直接与GPIO引脚绑定，而是通过可配置的**中断输入线（XINT1-XINT5）** 与GPIO引脚映射相连。这种设计提供了极大的灵活性。

- **核心中断路径**（简化流程）：  
  **GPIO引脚事件** -> **GPIO复用选择器** -> **XINTn 中断线** -> **PIE 组** -> **CPU INT**

- **主要组件说明**：
  
  | **组件**                                   | **功能**                                  | **C2000特点**                                                       |
  | ---------------------------------------- | --------------------------------------- | ----------------------------------------------------------------- |
  | **XINT (External Interrupt)**            | 专门管理外部中断的外设。每个XINT线可独立配置触发条件和连接的GPIO引脚。 | F2837x通常有5个（XINT1-XINT5）。每个XINT只能连接一个GPIO引脚，但一个引脚可映射到多个XINT（不常见）。 |
  | **PIE (Peripheral Interrupt Expansion)** | 将大量外设中断源复用、仲裁并映射到有限的CPU中断线上。            | C2000的特色架构。共12组（INT1-INT12），每组最多8个中断源。XINT1-5通常位于INT1组。           |
  | **中断服务程序 (ISR)**                         | 发生中断时执行的函数。                             | 需要在PIE向量表中注册。使用`__interrupt`关键字定义。                                |

### 3.2 外部中断初始化与配置

- **核心配置流程**（五步关键操作）：
  
  1. **配置GPIO引脚为输入**（并设置上拉/下拉，以满足硬件需求）
  
  2. **配置GPIO复用功能连接到XINT**（至关重要的一步！）
  
  3. **配置XINT模块**（选择触发边沿、使能中断）
  
  4. **配置PIE并注册ISR**（将XINTn中断源连接到对应的PIE位和ISR函数）
  
  5. **全局使能中断**

- **基础配置示例**（配置GPIO0连接到XINT1，下降沿触发）：
  
  ```c
  #include "driverlib.h"
  
  // 中断服务函数声明
  __interrupt void xint1ISR(void);
  
  void main(void) {
      // 1. 初始化器件、GPIO、PIE (通常由Device_init()完成部分)
      Device_init();
      Device_initGPIO();
      Interrupt_initModule();         // 初始化PIE模块
      Interrupt_initVectorTable();    // 初始化PIE向量表
  
      // 2. 配置GPIO0 - 设置为输入，并根据硬件连接配置上下拉
      GPIO_setPinConfig(GPIO_0_GPIO0);        // 功能：GPIO
      GPIO_setDirectionMode(0, GPIO_DIR_MODE_IN); // 方向：输入
      GPIO_setPadConfig(0, GPIO_PIN_TYPE_PULLUP); // 上拉（假设按键另一端接地）
  
      // 3. 配置XINT1 - 将其输入源设置为GPIO0，下降沿触发，并使能
      XINT_Config xint1Config;
      xint1Config.trigger = XINT_TRIG_FALLING_EDGE; // 触发条件：下降沿
      xint1Config.pin = 0;                          // 输入源：GPIO0
      xint1Config.enableInt = true;                 // 使能XINT1中断
      XINT_setConfig(XINT_BASE_1, &xint1Config);    // 应用配置
  
      // 4. 配置PIE - 将XINT1中断源连接到其ISR
      // XINT1属于INT1组，第4个中断源 (INT1.4)
      Interrupt_register(INT_XINT1, &xint1ISR); // 注册中断服务函数
      Interrupt_enable(INT_XINT1);               // 使能PIE组内的XINT1中断
  
      // 5. 清除任何可能存在的挂起标志，然后全局使能中断
      XINT_clearEventFlag(XINT_BASE_1); // 清除XINT1事件标志
      Interrupt_clear(INT_XINT1);       // 清除PIE组内的应答标志
      Interrupt_globalEnable(TRUE);     // 全局使能中断(清除INTM位)
  
      while(1) {
          // 主循环
      }
  }
  
  // 6. 实现中断服务函数 (ISR)
  __interrupt void xint1ISR(void) {
      // 在此处理中断事件，例如翻转一个LED
      GPIO_togglePin(31);
  
      // ！！！必须清除中断标志 ！！！
      XINT_clearEventFlag(XINT_BASE_1); // 清除XINT模块的事件标志
      Interrupt_clear(INT_XINT1);       // 通知PIE和CPU该中断已处理
  }
  ```

- **关键配置函数详解**：
  
  | **函数 (DriverLib)**                                                    | **说明**                                   | **参数示例与解释**                                                                                                                                                                             |
  | --------------------------------------------------------------------- | ---------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  | `XINT_setConfig(XINT_Base base, const XINT_Config *config)`           | **配置XINT模块的核心函数**。                       | `base`: `XINT_BASE_1` ~ `XINT_BASE_5`<br>`config`: 指向配置结构体的指针                                                                                                                           |
  | `XINT_Config` 结构体                                                     | 包含XINT的所有配置参数。                           | <ul><li>`trigger`: 触发条件 (`XINT_TRIG_FALLING_EDGE`, `RISING_EDGE`, `BOTH_EDGES`)</li><li>`pin`: 连接的**GPIO引脚编号** (如 `0` for GPIO0)</li><li>`enableInt`: 是否使能中断 (`true`/`false`)</li></ul> |
  | `Interrupt_register(uint32_t interruptNumber, void (*handler)(void))` | **将中断源与ISR函数进行绑定（注册）**。                  | `interruptNumber`: PIE中断号宏 (如 `INT_XINT1`)<br>`handler`: 中断服务函数的函数指针                                                                                                                    |
  | `Interrupt_enable(uint32_t interruptNumber)`                          | **使能PIE组内的特定中断源**。                       | `interruptNumber`: PIE中断号宏 (如 `INT_XINT1`)                                                                                                                                              |
  | `Interrupt_disable(uint32_t interruptNumber)`                         | **禁用PIE组内的特定中断源**。                       | `interruptNumber`: PIE中断号宏                                                                                                                                                              |
  | `XINT_clearEventFlag(XINT_Base base)`                                 | **清除XINT模块的事件标志位**。在ISR中**必须调用**。        | `base`: `XINT_BASE_1` ~ `XINT_BASE_5`                                                                                                                                                   |
  | `Interrupt_clear(uint32_t interruptNumber)`                           | **清除PIE和CPU层面的中断标志（ACK）**。在ISR中**必须调用**。 | `interruptNumber`: PIE中断号宏                                                                                                                                                              |

### 3.3 高级功能与特性

- **软件强制中断**：  
  可以通过软件模拟一个外部中断事件，常用于测试。
  
  ```c
  // 软件强制触发一次XINT1中断
  XINT_forceInterrupt(XINT_BASE_1);
  // 强制后，ISR会被执行，就像真的发生了硬件事件一样
  ```

- **中断优先级**：  
  C2000的硬件中断优先级是固定的，由其在PIE向量表中的位置决定。
  
  - **PIE组优先级**：INT1 > INT2 > ... > INT12 (INT1优先级最高)。
  
  - **组内优先级**：INTx.1 > INTx.2 > ... > INTx.8 (INTx.1优先级最高)。
  
  - **XINT默认位置**：XINT1-5通常在INT1组，所以XINT1(INT1.4)的优先级高于XINT2(INT1.5)。
  
  - 优先级只能通过将中断源分配到不同的PIE组来间接调整，但XINT的位置是固定的。

- **中断状态查询**：  
  可以查询中断是否被挂起，用于调试或状态检查。
  
  ```c
  // 检查XINT1是否有未处理的中断事件
  if (XINT_getEventStatus(XINT_BASE_1) == true) {
      // 事件标志被置位
  }
  ```

### 3.4 使用示例（按键唤醒与处理）

#### **示例：配置XINT1和XINT2，分别响应两个按键**

```c
#include "driverlib.h"

#define BUTTON1_PIN    0   // 连接到XINT1
#define BUTTON2_PIN    1   // 连接到XINT2
#define LED1_PIN       31
#define LED2_PIN       15

__interrupt void xint1ISR(void); // 按键1 ISR
__interrupt void xint2ISR(void); // 按键2 ISR

void main(void) {
    Device_init();
    Device_initGPIO();
    Interrupt_initModule();
    Interrupt_initVectorTable();

    // 初始化LEDs
    GPIO_setupPinMux(LED1_PIN, GPIO_MUX_CPU1, 0);
    GPIO_setupPinOptions(LED1_PIN, GPIO_OUTPUT, GPIO_PUSHPULL);
    GPIO_writePin(LED1_PIN, 0);
    // ... 类似初始化LED2 ...

    // 初始化按键GPIO (上拉输入)
    GPIO_setupPinMux(BUTTON1_PIN, GPIO_MUX_CPU1, 0);
    GPIO_setupPinOptions(BUTTON1_PIN, GPIO_INPUT, GPIO_PULLUP);
    // ... 类似初始化BUTTON2 ...

    // 配置XINT1 for BUTTON1 (下降沿)
    XINT_Config xint1Cfg = {XINT_TRIG_FALLING_EDGE, BUTTON1_PIN, true};
    XINT_setConfig(XINT_BASE_1, &xint1Cfg);
    Interrupt_register(INT_XINT1, &xint1ISR);
    Interrupt_enable(INT_XINT1);

    // 配置XINT2 for BUTTON2 (上升沿)
    XINT_Config xint2Cfg = {XINT_TRIG_RISING_EDGE, BUTTON2_PIN, true};
    XINT_setConfig(XINT_BASE_2, &xint2Cfg);
    Interrupt_register(INT_XINT2, &xint2ISR);
    Interrupt_enable(INT_XINT2);

    // 清除标志，全局使能中断
    XINT_clearEventFlag(XINT_BASE_1);
    XINT_clearEventFlag(XINT_BASE_2);
    Interrupt_clear(INT_XINT1);
    Interrupt_clear(INT_XINT2);
    Interrupt_globalEnable(TRUE);

    while(1) {
        // 主循环可进入低功耗模式，由中断唤醒
        asm(" NOP"); // 空操作，保持CPU活动，实际应用中可能是IDLE
    }
}

__interrupt void xint1ISR(void) {
    GPIO_togglePin(LED1_PIN);    // 按键1按下，翻转LED1
    XINT_clearEventFlag(XINT_BASE_1);
    Interrupt_clear(INT_XINT1);
}

__interrupt void xint2ISR(void) {
    GPIO_togglePin(LED2_PIN);    // 按键2释放，翻转LED2
    XINT_clearEventFlag(XINT_BASE_2);
    Interrupt_clear(INT_XINT2);
}
```

## 4. 关键注意事项

1. **GPIO复用配置是前提**：必须确保GPIO引脚已通过`GPIO_setPinConfig`或`GPIO_setupPinMux`正确设置为**普通GPIO功能**，而不是其他外设功能。这是中断无法触发的常见原因。

2. **双标志清除机制**：在ISR中**必须清除两个标志**：
   
   - **XINT事件标志** (`XINT_clearEventFlag`)：表明中断事件发生。
   
   - **PIE组标志** (`Interrupt_clear`)：通知中断控制器该中断已被处理，否则将持续触发。

3. **中断延迟**：C2000的中断响应延迟非常低，但对于极高速的信号，仍需考虑GPIO的**输入量化（Qualification）** 设置（见GPIO章节），以防止噪声误触发。

4. **电平触发与保持**：C2000的XINT是**边沿触发**的。如果引脚上的低电平（或高电平）一直保持，它不会持续产生中断，只会在边沿变化时产生一次。

5. **PIE向量表**：使用DriverLib的`Interrupt_register()`函数可以安全地管理PIE向量表，无需手动操作向量表地址，避免了常见错误。

6. **库函数差异**：对于F28004x等较新平台，函数名可能略有不同（如`Interrupt_registerPIE()`），但核心概念和配置步骤完全一致。务必查阅所用芯片的DriverLib文档。

---
